import { createFilter } from '@rollup/pluginutils';
import path from 'path';

var index = (options = {}) => {
  if (!options.transform)
    options.transform = (code) => code;
  const styles = {};
  const alwaysOutput = options.alwaysOutput ?? false;
  const filter = createFilter(options.include ?? ["**/*.css"], options.exclude ?? []);
  const getRecursiveImportOrder = (id, getModuleInfo, seen = /* @__PURE__ */ new Set()) => {
    if (seen.has(id))
      return [];
    seen.add(id);
    const result = [id];
    const moduleInfo = getModuleInfo(id);
    if (moduleInfo) {
      getModuleInfo(id).importedIds.forEach((importFile) => {
        result.push(...getRecursiveImportOrder(importFile, getModuleInfo, seen));
      });
    }
    return result;
  };
  const minifyCSS = (content) => {
    content = content.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "");
    content = content.replace(/ {2,}/g, " ");
    content = content.replace(/ ([{:}]) /g, "$1");
    content = content.replace(/([{:}]) /g, "$1");
    content = content.replace(/([;,]) /g, "$1");
    content = content.replace(/ !/g, "!");
    return content;
  };
  return {
    name: "import-css",
    /* convert the css file to a module and save the code for a file output */
    transform(code, id) {
      var _a;
      if (!filter(id))
        return;
      const transformedCode = options.minify ? minifyCSS(options.transform(code)) : options.transform(code);
      if (!styles[id] || styles[id] != transformedCode) {
        styles[id] = transformedCode;
      }
      const moduleInfo = this.getModuleInfo(id);
      if (options.modules || ((_a = moduleInfo.assertions) == null ? void 0 : _a.type) == "css") {
        return {
          code: `const sheet = new CSSStyleSheet();sheet.replaceSync(${JSON.stringify(transformedCode)});export default sheet;`,
          map: { mappings: "" }
        };
      }
      if (options.inject) {
        return {
          code: `document.head.appendChild(document.createElement('style')).textContent=${JSON.stringify(transformedCode)};`,
          map: { mappings: "" }
        };
      }
      return {
        code: `export default ${JSON.stringify(transformedCode)};`,
        map: { mappings: "" }
      };
    },
    /* output a css file with all css that was imported without being assigned a variable */
    generateBundle(opts, bundle) {
      const modules = Object.keys(bundle).reduce((modules2, file) => Object.assign(modules2, bundle[file].modules), {});
      const entryChunk = Object.values(bundle).find((chunk) => chunk.facadeModuleId).facadeModuleId;
      const stylesheets = Object.keys(styles).filter((id) => !modules[id]);
      if (!stylesheets.length)
        return;
      const moduleIds = getRecursiveImportOrder(entryChunk, this.getModuleInfo);
      stylesheets.sort((a, b) => moduleIds.indexOf(a) - moduleIds.indexOf(b));
      if (opts.preserveModules) {
        for (let id of stylesheets) {
          const relativeToEntry = path.dirname(path.relative(entryChunk, id));
          const outputPath = opts.dir ? opts.dir : path.dirname(opts.file);
          const fileName = path.join(path.join(outputPath, relativeToEntry), path.basename(id));
          if (styles[id].trim().length <= 0 && !alwaysOutput)
            continue;
          this.emitFile({ type: "asset", fileName, source: styles[id] });
        }
        return;
      }
      const css = stylesheets.map((id) => styles[id]).join("\n");
      if (css.trim().length <= 0 && !alwaysOutput)
        return;
      const getAssetName = () => {
        const fileName = options.output ?? (opts.file ?? "bundle.js");
        return `${path.basename(fileName, path.extname(fileName))}.css`;
      };
      const getAssetFileName = () => {
        if (options.output)
          return options.output;
        if (opts.assetFileNames)
          return void 0;
        return getAssetName();
      };
      this.emitFile({
        type: "asset",
        name: getAssetName(),
        fileName: getAssetFileName(),
        source: css
      });
    }
  };
};

export { index as default };
